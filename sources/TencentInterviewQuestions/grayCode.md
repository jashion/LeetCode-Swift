### 题目：

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

```
示例 1:

输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
示例 2:

输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
```

这里需要搞清楚一个概念：格雷编码

两个相邻的二进制编码，只有一位的差异，比如：00和01，010和110，各自代表的十进制并不需要连续，比如：00和01，00和10等等。

输入数字n指的是二进制的位数，比如n=3，也就是三位二进制，也就是有2^3=8种可能。

### 解法一：

镜像法。

```
n = 0   1     2      3   ...
    0   0    00    000
        1    01    001
             10    010
             11    011
                   111
                   110
                   101
                   100 
```

当n = 0时，res = [0]

当n = 1时，res = [0, 1]

当n = 2时,   由于一个二进制只有0和1这两种可能，增加一位，也就在前面的基础上，每一个元素前面追加一个0或者1，追加0时，res0 = [00, 01]，但是追加1时，顺序需要变一下，因为格雷码两个编码之间只相差一位，所以需要逆序添加，res1 = [11, 10]。逆序的时候，如果没有添加0或者1，前面res0最后一位和res1第一位是相等的，只有前面一位的不等。res1后面的数字第一位是相等的，后面两位是符合格雷编码的。

```swift
 class Solution {
    func grayCode(_ n: Int) -> [Int] {
        var res = [0]
        var i = 1
        while i <= n {
            let tmp = res.reversed()
            for item in tmp {
                res.append(item+Int(pow(2.0, Double(i-1))))
            }
            i += 1
        }
        return res
    }
 }
```

### 解法二：

格雷编码公式：

| 十进制 | 二进制  | 格雷码  | 十进制 | 二进制  | 格雷码  |
| --- | ---- | ---- | --- | ---- | ---- |
| 0   | 0000 | 0000 | 6   | 0110 | 0101 |
| 1   | 0001 | 0001 | 7   | 0111 | 0100 |
| 2   | 0010 | 0011 | 8   | 1000 | 1100 |
| 3   | 0011 | 0010 | 9   | 1001 | 1101 |
| 4   | 0100 | 0110 | 10  | 1010 | 1111 |
| 5   | 0101 | 0111 | 11  | 1011 | 1110 |

可以得出公式

G(n) = n ^ (n>>1)

n的格雷码等于n右移一位然后和n异或得出来的结果。

```swift
 class Solution {
    func grayCode(_ n: Int) -> [Int] {
        var res = [Int]()
        for i in 0..<Int(powf(2.0, Float(n))) {
            res.append(i^(i>>1))
        }
        return res
    }
 }
```
