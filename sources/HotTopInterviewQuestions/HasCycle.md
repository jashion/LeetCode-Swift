### 题目：

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

### 解法一：双指针

第一眼看到这道题，脑海就浮现出双指针法，很明显的一道使用双指针计算的算法题。

```c
bool hasCycle(struct ListNode *head) {
    if (!head || !head->next) {
        return false;
    }
    struct ListNode *slow = head;
    struct ListNode *fast = head;
    while (slow->next && fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

### 解法二：Map法

除了双指针法，还可以使用Map。遍历链表，判断当前结点是否包含在Map里面，如果没有就添加进去，如有有，则表示链表有环。由于C语言没有Map，所以这里只提供思路。

### 解法三：数组法

和解法二的思路一样，只不过换成了数组，不过算法复杂度比较高，需要不断遍历数组。

### 解法四：投机取巧法

（1）链表有环，表示遍历时一定有结点会被重复访问，那么我们可以把访问过的结点标记一下，比如将访问过的结点的数值设置成不太可能的数值（还是有重复的风险）来表示该结点已被访问。当再次遇到结点的值为不太可能的数值时，就表示链表有环。（该算法存在风险，假如不太可能的值真的存在，则就算链表没有环也会被视为有环，并且这样会破坏原来的链表的结构）。

（2）新生成一个结点node，每访问过一个结点，就将node赋值给该结点的next，如果遍历的过程中遇到node，则表示链表有环，反之，则链表没有环。（这个也会破坏原有链表的结构）
